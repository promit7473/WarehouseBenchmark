# source/envs/mdp/events.py

import torch
from isaaclab.assets import AssetBase
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import ManagerTermBase
from isaaclab.envs import ManagerBasedRLEnv

def randomize_obstacles(
    env: ManagerBasedRLEnv,
    env_ids: torch.Tensor,
    asset_cfg: SceneEntityCfg,
    x_range: tuple[float, float],
    y_range: tuple[float, float]
 ):
    """
    Randomizes the position of the obstacles within a specified range.
    This is called every time the environment resets.
    """
    # 1. Get the asset (Crates/Pallets)
    asset: AssetBase = env.scene[asset_cfg.name]

    # 2. Get the current state of the asset
    # The state is a tensor of shape (num_envs, num_bodies, 13)
    # 13 = pos(3) + quat(4) + lin_vel(3) + ang_vel(3)
    root_state = asset.data.default_root_state[env_ids].clone()

    # 3. Generate random positions
    # We create random numbers between 0 and 1, then scale to our range
    num_envs = len(env_ids)

    # Random X
    rand_x = torch.rand(num_envs, device=env.device) * (x_range[1] - x_range[0]) + x_range[0]
    # Random Y
    rand_y = torch.rand(num_envs, device=env.device) * (y_range[1] - y_range[0]) + y_range[0]

    # 4. Apply to the root state
    root_state[:, 0] = rand_x # Set X
    root_state[:, 1] = rand_y # Set Y

    # 5. Apply the new state to the simulator
    asset.write_root_state_to_sim(root_state, env_ids)  # type: ignore


def warehouse_aware_waypoint_generation(
    env: ManagerBasedRLEnv,
    env_ids: torch.Tensor,
    command_name: str
):
    """
    Generate waypoints that are aware of warehouse layout (aisles, shelves).
    Based on omni warehouse creator extension knowledge.

    Note: This function generates waypoints and triggers command resampling.
    The actual command values are managed by the command manager's internal state.
    """
    # This would generate waypoints along aisles and near shelves
    # Instead of random positions, use warehouse-aware positioning

    num_envs = len(env_ids)

    # Generate waypoints in warehouse aisles
    # This would integrate with the warehouse USD layout
    aisle_positions = torch.zeros(num_envs, 3, device=env.device)  # [x, y, heading]

    # For now, use constrained random positions that simulate aisles
    # full_warehouse.usd actual bounds: X=[-28, 8], Y=[-41, 33] with 2m margin
    aisle_positions[:, 0] = torch.rand(num_envs, device=env.device) * 32.0 - 15.0  # X: [-15, 17]
    aisle_positions[:, 1] = torch.rand(num_envs, device=env.device) * 56.0 - 28.0  # Y: [-28, 28]
    aisle_positions[:, 2] = torch.rand(num_envs, device=env.device) * 6.28 - 3.14  # heading: [-pi, pi]

    # Use the command manager's reset method to resample commands for specified envs
    # Note: Isaac Lab's command manager uses reset() or resample() instead of set_command()
    try:
        env.command_manager.reset(env_ids)
    except (AttributeError, TypeError):
        # Fallback: directly modify the command tensor if reset not available
        try:
            command = env.command_manager.get_command(command_name)
            command[env_ids] = aisle_positions
        except Exception:
            pass  # Command manager may not support direct modification


def randomize_warehouse_obstacles(
    env: ManagerBasedRLEnv,
    env_ids: torch.Tensor,
    asset_cfg: SceneEntityCfg
):
    """
    Randomize warehouse obstacles while respecting aisle layouts.
    Based on warehouse logistics tutorial for dynamic environments.
    """
    asset: AssetBase = env.scene[asset_cfg.name]
    root_state = asset.data.default_root_state[env_ids].clone()

    num_envs = len(env_ids)

    # Generate positions that don't block main aisles
    # This would use warehouse layout knowledge
    rand_x = torch.rand(num_envs, device=env.device) * 30.0 - 15.0  # Avoid aisle centers
    rand_y = torch.rand(num_envs, device=env.device) * 30.0 - 15.0

    root_state[:, 0] = rand_x
    root_state[:, 1] = rand_y

    asset.write_root_state_to_sim(root_state, env_ids)


def initialize_waypoints(
    env: ManagerBasedRLEnv,
    env_ids: torch.Tensor
 ):
    """
    Initialize sequential waypoints for each environment.
    Uses warehouse-aware waypoint generation that follows aisle patterns.
    """
    # Initialize waypoint index to 0 for new episodes
    if not hasattr(env, 'waypoint_index'):
        env.waypoint_index = torch.zeros(env.num_envs, dtype=torch.long, device=env.device)

    env.waypoint_index[env_ids] = 0

    # Don't manually set commands - let the system handle command generation
    # The commands will be generated by the UniformPose2dCommandCfg


def progress_waypoints(
    env: ManagerBasedRLEnv, env_ids: torch.Tensor
):
    """
    Check if robot has reached current waypoint and progress to next.
    Also draws waypoint arrows for visualization.

    Args:
        env: The environment instance
        env_ids: Tensor of environment indices to check (unused, checks all envs)
    """
    # Get robot positions
    robot = env.scene["robot"]
    robot_pos = robot.data.root_state_w[:, :3]  # x, y, z positions

    # Define warehouse-aware waypoints [x, y, heading]
    waypoints = torch.tensor([
        [0.0, -8.0, 0.0],    # Waypoint 1: Loading area
        [3.5, 0.0, 1.57],    # Waypoint 2: First aisle (facing north)
        [3.5, 6.0, 0.0],     # Waypoint 3: Shelf area
        [0.0, -8.0, -1.57]   # Waypoint 4: Return to loading (facing south)
    ], device=env.device)

    # Ensure waypoint_index exists
    if not hasattr(env, 'waypoint_index'):
        env.waypoint_index = torch.zeros(env.num_envs, dtype=torch.long, device=env.device)

    # Current waypoint for each env
    current_indices = env.waypoint_index
    current_waypoints = waypoints[current_indices]

    # Distance to current waypoint (only x,y)
    distances = torch.norm(robot_pos[:, :2] - current_waypoints[:, :2], dim=1)

    # Threshold for reaching waypoint
    threshold = 1.0  # 1 meter

    # Find envs that reached waypoint
    reached = distances < threshold

    if reached.any():
        # Progress to next waypoint
        env.waypoint_index[reached] += 1

        # Reset to 0 if all waypoints done (loop)
        num_waypoints = waypoints.shape[0]
        env.waypoint_index[reached] = env.waypoint_index[reached] % num_waypoints

        # Update command to new waypoint position and heading
        try:
            command = env.command_manager.get_command("waypoint_nav")
            new_indices = env.waypoint_index[reached]
            # Command format is [x, y, heading] for UniformPose2dCommand
            command[reached, :3] = waypoints[new_indices]
        except (KeyError, AttributeError, IndexError) as e:
            import logging
            logging.getLogger(__name__).debug(f"Could not update waypoint command: {e}")




def update_current_goal_indicator(
    env: ManagerBasedRLEnv, env_ids: torch.Tensor = None
):
    """
    Update the current goal indicator and direction arrow.

    Args:
        env: The environment instance
        env_ids: Tensor of environment indices to update. If None, updates all environments.
    """
    # Handle None env_ids - default to all environments
    if env_ids is None:
        env_ids = torch.arange(env.num_envs, device=env.device)

    # Check if waypoint_index exists
    if not hasattr(env, 'waypoint_index'):
        return  # Nothing to update if waypoints not initialized

    # Define warehouse-aware waypoints (ground positions for indicators)
    waypoints = torch.tensor([
        [0.0, -8.0, 0.0],    # Waypoint 1: Loading area
        [3.5, 0.0, 0.0],     # Waypoint 2: First aisle
        [3.5, 6.0, 0.0],     # Waypoint 3: Shelf area
        [0.0, -8.0, 0.0]     # Waypoint 4: Return to loading
    ], device=env.device)

    # Get current waypoint index
    current_indices = env.waypoint_index[env_ids]

    # Get target positions for these envs
    target_positions = waypoints[current_indices]

    # Update the current target indicator position (above waypoints)
    indicator_positions = target_positions + torch.tensor([0.0, 0.0, 3.0], device=env.device)

    # Try to update visual indicator if it exists in the scene
    try:
        current_target = env.scene["CurrentTarget"]
        current_target.set_world_poses(indicator_positions.unsqueeze(1), env_ids)
    except KeyError:
        # CurrentTarget not defined in scene - this is expected if not using visual indicators
        pass
    except (AttributeError, RuntimeError) as e:
        # Log unexpected errors for debugging
        import logging
        logging.getLogger(__name__).debug(f"Could not update goal indicator: {e}")


